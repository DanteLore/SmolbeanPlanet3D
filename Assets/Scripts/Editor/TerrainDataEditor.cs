using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(TerrainData))]
public class TTerrainDataEditor : Editor
{
    private static float[] rotationAngles = {0f, 90f, 180f, 270f};

    const string baseFolder = "Assets/Meshes";
    const string meshFolder = "TerrainMeshesAutoGenerated";
    private float FuzzyEdgeFactor { get { return ((TerrainData)target).fuzzyEdgeFactor; }}

    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();

        if(GUILayout.Button("Process Meshes"))
        {
            string filename = EditorUtility.OpenFilePanel("Select an FBX File", "Assets/Meshes", "fbx");

            if(filename.Length > 0)
                ProcessMeshes(filename);

            EditorUtility.SetDirty(target);
        }
    }

    private void ProcessMeshes(string filename)
    {
        DateTime startTime = DateTime.Now;
        var td = (TerrainData)target;
        string assetFile = "Assets" + filename.Substring(Application.dataPath.Length);
        var baseMeshes = LoadMeshes(assetFile);
        var derivedMeshes = baseMeshes.SelectMany(CreateChildMeshes).ToArray();
        td.meshData = derivedMeshes;
        td.neighbourData = new NeighbourSelector(FuzzyEdgeFactor, td.meshData, td.levelMeshHeight).SelectNeighbours().ToArray();
        Debug.Log($"Mesh data processed in {(DateTime.Now - startTime).TotalSeconds}s");
    }

    private IEnumerable<MeshData> CreateChildMeshes(MeshData baseMeshData)
    {
        int max = Mathf.Max(1, ((TerrainData)target).MaxLevelNumber - 1);
        int[] levels = baseMeshData.name.ToLower().Contains("sea") ? new int[] { 0 } : Enumerable.Range(0, max).ToArray();

        foreach (float angle in rotationAngles)
            foreach (var level in levels)
                yield return CreateTransformedMesh(baseMeshData, angle, level);
    }

    private MeshData CreateTransformedMesh(MeshData baseMeshData, float angle, int level)
    {
        // Copy and transform the mesh and associated datas
        var offset = new Vector3(0f, level * ((TerrainData)target).levelMeshHeight, 0f);
        var rotated = RotateMesh(CloneMesh(baseMeshData.mesh), angle);
        var translated = CreateMeshData(TranslateMesh(rotated, offset));

        // Use the parent mesh, and record transform details to apply at runtime
        translated.mesh = AssetDatabase.LoadAssetAtPath<Mesh>($"{baseFolder}/{meshFolder}/{baseMeshData.name}.asset");
        translated.name = $"{baseMeshData.name} rotated Y {Mathf.RoundToInt(angle)} translated Y {offset.y}";
        translated.id = translated.name.GetHashCode();
        translated.rotationAngles.y = angle;
        translated.translation = offset;
        return translated;
    }

    private List<MeshData> LoadMeshes(string filename)
    {
        var meshes = AssetDatabase
            .LoadAllAssetsAtPath(filename)
            .Where(o => o is Mesh)
            .Select(m => (Mesh)m)
            .Select(CloneMesh)
            .ToList();

        if(!AssetDatabase.IsValidFolder($"{baseFolder}/{meshFolder}"))
            AssetDatabase.CreateFolder(baseFolder, meshFolder);

        foreach(var m in meshes)
        {
            AssetDatabase.CreateAsset(m, $"{baseFolder}/{meshFolder}/{m.name}.asset");
        }
        AssetDatabase.SaveAssets();

        return meshes.Select(CreateMeshData).ToList();
    }

    private MeshData CreateMeshData(Mesh mesh)
    {
        var edges = new List<Edge>();
        for(int i = 0; i < mesh.triangles.Length; i += 3)
        {
            Vector3 p1 = mesh.vertices[mesh.triangles[i]];
            Vector3 p2 = mesh.vertices[mesh.triangles[i + 1]];
            Vector3 p3 = mesh.vertices[mesh.triangles[i + 2]];

            edges.Add(new Edge { start = p1, end = p2 });
            edges.Add(new Edge { start = p2, end = p3 });
            edges.Add(new Edge { start = p3, end = p1 });
        }

        var leftBoundary = edges
            .Where(e => Mathf.Abs(e.start.x - mesh.bounds.min.x) <= FuzzyEdgeFactor && Mathf.Abs(e.end.x - mesh.bounds.min.x) <= FuzzyEdgeFactor)
            .Select(e => new Edge {start = new Vector3(0.0f, e.start.y, e.start.z), end = new Vector3(0.0f, e.end.y, e.end.z)});
        var rightBoundary = edges
            .Where(e => Mathf.Abs(e.start.x - mesh.bounds.max.x) <= FuzzyEdgeFactor && Mathf.Abs(e.end.x - mesh.bounds.max.x) <= FuzzyEdgeFactor)
            .Select(e => new Edge {start = new Vector3(0.0f, e.start.y, e.start.z), end = new Vector3(0.0f, e.end.y, e.end.z)});
        var frontBoundary = edges
            .Where(e => Mathf.Abs(e.start.z - mesh.bounds.min.z) <= FuzzyEdgeFactor && Mathf.Abs(e.end.z - mesh.bounds.min.z) <= FuzzyEdgeFactor)
            .Select(e => new Edge {start = new Vector3(e.start.x, e.start.y, 0.0f), end = new Vector3(e.end.x, e.end.y, 0.0f)});
        var backBoundary = edges
            .Where(e => Mathf.Abs(e.start.z - mesh.bounds.max.z) <= FuzzyEdgeFactor && Mathf.Abs(e.end.z - mesh.bounds.max.z) <= FuzzyEdgeFactor)
            .Select(e => new Edge {start = new Vector3(e.start.x, e.start.y, 0.0f), end = new Vector3(e.end.x, e.end.y, 0.0f)});

        float maxX = mesh.vertices.Max(v => v.x);
        float maxZ = mesh.vertices.Max(v => v.z);
        float minX = mesh.vertices.Min(v => v.x);
        float minZ = mesh.vertices.Min(v => v.z);

        Vector3 backLeft = new Vector3(minX, 0.0f, maxZ);
        Vector3 backRight = new Vector3(maxX, 0.0f, maxZ);
        Vector3 frontLeft = new Vector3(minX, 0.0f, minZ);
        Vector3 frontRight = new Vector3(maxX, 0.0f, minZ);

        var backLeftVertex = mesh.vertices.OrderBy(v => (new Vector3(v.x, 0.0f, v.z) - backLeft).sqrMagnitude).First();
        var backRightVertex = mesh.vertices.OrderBy(v => (new Vector3(v.x, 0.0f, v.z) - backRight).sqrMagnitude).First();
        var frontLeftVertex = mesh.vertices.OrderBy(v => (new Vector3(v.x, 0.0f, v.z) - frontLeft).sqrMagnitude).First();
        var frontRightVertex = mesh.vertices.OrderBy(v => (new Vector3(v.x, 0.0f, v.z) - frontRight).sqrMagnitude).First();

        return new MeshData
            {
                id = mesh.name.GetHashCode(),
                name = mesh.name,
                mesh = mesh,
                edges = edges.ToArray(),
                leftBoundary = leftBoundary.ToArray(),
                rightBoundary = rightBoundary.ToArray(),
                frontBoundary = frontBoundary.ToArray(),
                backBoundary = backBoundary.ToArray(),
                backLeftHeight = backLeftVertex.y,
                backRightHeight = backRightVertex.y,
                frontLeftHeight = frontLeftVertex.y,
                frontRightHeight = frontRightVertex.y,
                translation = Vector3.zero,
                rotationAngles = Vector3.zero
            };
    }

    private Mesh CloneMesh(Mesh m)
    {
        return new Mesh()
        {
            name = m.name,
            vertices = m.vertices,
            triangles = m.triangles,
            normals = m.normals,
            tangents = m.tangents,
            bounds = m.bounds,
            uv = m.uv
        };
    }

    private Mesh RotateMesh(Mesh mesh, float angleDegrees)
    {
        if(angleDegrees == 0f)
            return mesh;

        var rot = Quaternion.Euler(0.0f, angleDegrees, 0.0f);
        var rotatedVerts = mesh.vertices.Select(v => rot * v).ToArray();
        mesh.vertices = rotatedVerts;
        var rotatedNormals = mesh.normals.Select(v => rot * v).ToArray();
        mesh.normals = rotatedNormals;

        return mesh;
    }

    private Mesh TranslateMesh(Mesh mesh, Vector3 offset)
    {
        var translatedVerts = mesh.vertices.Select(v => v + offset).ToArray();
        mesh.vertices = translatedVerts;

        return mesh;
    }

}

