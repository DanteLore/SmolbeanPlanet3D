using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.InputSystem;

public class BuildManager : MonoBehaviour, IObjectGenerator
{
    public int Priority { get { return 100; } }

    public BuildingSpec[] buildings;
    public static BuildManager Instance;
    public GameObject mapCursorPrefab;
    public GameObject buildingEditWidgetPrefab;
    public string groundLayer = "Ground";
    public string buildingLayer = "Buildings";
    public string widgetLayer = "Widgets";
    public string[] collisionLayers = { "Nature", "Buildings", "Creatures" };
    public ParticleSystem buildingPlacedParticleSystem;
    public ParticleSystem buildingDeletedParticleSystem;
    public float allowedHeightDifferential = 0.2f;

    private GridManager gridManager;
    private GameMapGenerator gameMapGenerator;
    private GameObject mapCursor;
    private Vector2Int currentSquare;
    private Vector3 center;
    private bool okToBuild;
    public bool IsBuilding { get; private set; }
    public bool IsEditing { get; private set; }

    private Transform editTargetTransform;
    private int selectedBuildingIndex;
    private GameObject buildingEditWidget;
    private SoundPlayer soundPlayer;

    public IEnumerable<SmolbeanBuilding> Buildings
    {
        get
        {
            return GetComponentsInChildren<SmolbeanBuilding>();
        }
    }

    public void Generate(List<int> gameMap, int gameMapWidth, int gameMapHeight)
    {
        // Nothing to do here - buildings generated by the player!
    }

    void Awake()
    {
        if(Instance != null && Instance != this)
            Destroy(this);
        else   
            Instance = this;
    }

    void Start()
    {
        gridManager = FindObjectOfType<GridManager>();
        gameMapGenerator = FindObjectOfType<GameMapGenerator>();
        currentSquare = new Vector2Int(int.MaxValue, int.MaxValue);
        soundPlayer = GameObject.Find("SFXManager").GetComponent<SoundPlayer>();

        mapCursor = Instantiate(mapCursorPrefab, Vector3.zero, Quaternion.identity, transform.parent);
        mapCursor.SetActive(false);
    }

    public void BeginBuild(BuildingSpec spec)
    {
        if(IsEditing)
            EndEdit();

        selectedBuildingIndex = Array.IndexOf(buildings, spec);
        IsBuilding = true;
    }

    public void EndBuild()
    {
        IsBuilding = false;
        mapCursor.SetActive(false);
    }

    private void BeginEdit(Transform target)
    {
        IsEditing = true;
        editTargetTransform = target;
        buildingEditWidget = Instantiate(buildingEditWidgetPrefab, target.position, target.rotation, target);
        var edit = buildingEditWidget.GetComponent<BuildingEdit>();
        edit.BuildingDelete += DeleteTargetBuilding;
        edit.AllowDelete = target.gameObject.GetComponent<SmolbeanBuilding>().BuildingSpec.deleteAllowed;
    }

    private void EndEdit()
    {
        IsEditing = false;
        editTargetTransform = null;
        
        if(buildingEditWidget != null)
            Destroy(buildingEditWidget);
    }

    // TODO:  The following three "Update" methods should be illegal.  This is a shameful implementation of a state machine
    //        and if I weren't so tired of this code, I'd do some kind of massive refactor.
    //        as is stands though, just gonna leave it for Future Dan(tm) to sort out!

    void Update()
    {
        if (GameStateManager.Instance.IsPaused)
        {
            EndEdit();
            return;
        }

        bool isOverUI = UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject();
        if (isOverUI)
        {
            mapCursor.SetActive(false);
            return;
        }

        if (IsBuilding)
            UpdateBuildMode();
        else 
            UpdateSelectBuildingMode();
    }

    private void UpdateSelectBuildingMode()
    {
        if (!Mouse.current.leftButton.wasPressedThisFrame)
            return;

        var ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        bool hitSomething = Physics.Raycast(ray, out var hitInfo, float.MaxValue, LayerMask.GetMask(buildingLayer, widgetLayer));

        if(hitSomething && hitInfo.transform.gameObject.layer == LayerMask.NameToLayer(widgetLayer))
        {
            // If we hit a widget, do nothing here
            return;
        }

        if(IsEditing && !hitSomething) 
        {
            // User clicked off the building
            EndEdit();
        }
        else if(IsEditing && hitInfo.transform != editTargetTransform)
        {
            EndEdit();
            BeginEdit(hitInfo.transform);
        }
        else if(!IsEditing && hitSomething)
        {
            BeginEdit(hitInfo.transform);
        }
    }
    private void UpdateBuildMode()
    {
        var ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        if (!Physics.Raycast(ray, out var hitInfo, float.MaxValue, LayerMask.GetMask(groundLayer)))
        {
            mapCursor.SetActive(false);
            return;
        }

        Vector2Int newSquare = gridManager.GetGameSquareFromWorldCoords(hitInfo.point);

        bool mouseDown = Mouse.current.leftButton.wasPressedThisFrame;

        if (mouseDown && okToBuild)
        {
            PlaceBuilding(center);
            EndBuild();
        }
        else if (newSquare != currentSquare)
        {
            currentSquare = newSquare;

            int level = gridManager.GameMap[currentSquare.y * gameMapGenerator.mapWidth + currentSquare.x];

            var bounds = gridManager.GetSquareBounds(currentSquare.x, currentSquare.y);

            float worldX = bounds.center.x;
            float worldZ = bounds.center.y;
            float worldY = gridManager.GetGridHeightAt(worldX, worldZ);
            center = new Vector3(worldX, worldY, worldZ);
            okToBuild = CheckFlat(bounds) && CheckEmpty(center);

            Color color = okToBuild ? Color.blue : Color.red;
            mapCursor.transform.position = center;
            mapCursor.GetComponent<Renderer>().material.SetColor("_baseColor", color);
            mapCursor.SetActive(true);
        }
    }

    private void DeleteTargetBuilding()
    {
        Instantiate(buildingDeletedParticleSystem, editTargetTransform.position, editTargetTransform.rotation);
        Destroy(editTargetTransform.gameObject); 
        soundPlayer.Play("Demolish");
        EndEdit();
    }

    private void PlaceBuilding(Vector3 pos)
    {
        BuildingObjectSaveData saveData = new BuildingObjectSaveData
        {
            positionX = pos.x,
            positionY = pos.y,
            positionZ = pos.z,
            rotationY = 0,
            prefabIndex = selectedBuildingIndex,
            complete = buildings[selectedBuildingIndex].instantBuild
        };

        InstantiateBuilding(saveData);

        soundPlayer.Play("Thud");
        Instantiate(buildingPlacedParticleSystem, pos, Quaternion.identity);
    }

    public SmolbeanBuilding CompleteBuild(BuildingSite site)
    {
        BuildingObjectSaveData saveData = new BuildingObjectSaveData
        {
            positionX = site.transform.position.x,
            positionY = site.transform.position.y,
            positionZ = site.transform.position.z,
            rotationY = site.transform.rotation.eulerAngles.y,
            prefabIndex = site.PrefabIndex,
            complete = true
        };

        DestroyImmediate(site.gameObject);
        return InstantiateBuilding(saveData);
    }

    public SmolbeanBuilding PlaceBuildingOnSquare(BuildingSpec spec, int x, int y, IEnumerable<InventoryItemSaveData> startingInventory = null)
    {
        var bounds = gridManager.GetSquareBounds(x, y);

        float worldX = bounds.center.x;
        float worldZ = bounds.center.y;
        float worldY = gridManager.GetGridHeightAt(worldX, worldZ);

        BuildingObjectSaveData saveData = new BuildingObjectSaveData
        {
            positionX = worldX,
            positionY = worldY,
            positionZ = worldZ,
            rotationY = 0,
            prefabIndex = Array.IndexOf(buildings, spec),
            complete = true,
            inventory = startingInventory
        };

        return InstantiateBuilding(saveData);
    }

    private SmolbeanBuilding InstantiateBuilding(BuildingObjectSaveData saveData)
    {
        Vector3 pos = new Vector3(saveData.positionX, saveData.positionY, saveData.positionZ);
        Vector2Int worldPos = gridManager.GetGameSquareFromWorldCoords(pos);

        var spec = buildings[saveData.prefabIndex];
        var prefab = saveData.complete ? spec.prefab : spec.sitePrefab;
       
        var buildingObject = Instantiate(prefab, pos, Quaternion.Euler(0f, saveData.rotationY, 0f), transform);
        var building = buildingObject.GetComponent<SmolbeanBuilding>();
        building.transform.position = pos; // Need to do this to allow access to position on same frame
        building.PrefabIndex = saveData.prefabIndex;
        building.BuildingSpec = buildings[saveData.prefabIndex];
        building.name = $"{buildings[saveData.prefabIndex].buildingName} ({worldPos.y}N {worldPos.x}E)";

        if(saveData.inventory != null)
            building.Inventory.LoadFrom(saveData.inventory);

        return building;
    }

    private bool CheckEmpty(Vector3 center)
    {
        Vector3 boxCentre = new Vector3(center.x, center.y + gridManager.tileSize / 2.0f, center.z);
        Vector3 halfExtents = new Vector3(gridManager.tileSize / 2.0f, gridManager.tileSize / 2.0f, gridManager.tileSize / 2.0f);
        var objects = Physics.OverlapBox(center, halfExtents, Quaternion.identity, LayerMask.GetMask(collisionLayers));
        return objects.Length == 0;
    }

    private bool CheckFlat(Rect bounds)
    {
        float marginSize = 0.05f;
        float rayStartHeight = 1000f;

        float rayLength = 2.0f * rayStartHeight;
        float margin = bounds.width * marginSize;

        var ray1 = new Ray(new Vector3(bounds.xMin + margin, rayStartHeight, bounds.yMin + margin), Vector3.down);
        if(!Physics.Raycast(ray1, out var hit1, rayLength, LayerMask.GetMask(groundLayer)))
            return false;

        float height = hit1.point.y;

        var ray2 = new Ray(new Vector3(bounds.xMax - margin, rayStartHeight, bounds.yMin + margin), Vector3.down);
        if(!Physics.Raycast(ray2, out var hit2, rayLength, LayerMask.GetMask(groundLayer)))
            return false;

        if(Mathf.Abs(hit2.point.y - height) > allowedHeightDifferential)
            return false;

        var ray3 = new Ray(new Vector3(bounds.xMin + margin, rayStartHeight, bounds.yMax - margin), Vector3.down);
        if(!Physics.Raycast(ray3, out var hit3, rayLength, LayerMask.GetMask(groundLayer)))
            return false;

        if(Mathf.Abs(hit3.point.y - height) > allowedHeightDifferential)
            return false;

        var ray4 = new Ray(new Vector3(bounds.xMax - margin, rayStartHeight, bounds.yMax - margin), Vector3.down);
        if(!Physics.Raycast(ray4, out var hit4, rayLength, LayerMask.GetMask(groundLayer)))
            return false;

        if(Mathf.Abs(hit4.point.y - height) > allowedHeightDifferential)
            return false;

        return true;
    }

    public void Clear()
    {
        while (transform.childCount > 0)
            DestroyImmediate(transform.GetChild(0).gameObject);
    }

    public List<BuildingObjectSaveData> GetSaveData()
    {
        return GetComponentsInChildren<SmolbeanBuilding>()
            .Select(b => new BuildingObjectSaveData
            {
                positionX = b.transform.position.x,
                positionY = b.transform.position.y,
                positionZ = b.transform.position.z,
                rotationY = b.transform.rotation.eulerAngles.y,
                prefabIndex = b.PrefabIndex,
                inventory = b.Inventory.GetSaveData(),
                complete = !(b is BuildingSite)
            })
            .ToList();
    }

    public void LoadBuildings(List<BuildingObjectSaveData> loadedData)
    {
        Clear();

        foreach(var buildingData in loadedData)
            InstantiateBuilding(buildingData);
    }
}
