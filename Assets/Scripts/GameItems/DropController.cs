using System.Collections.Generic;
using System.Collections;
using UnityEngine;
using System.Linq;
using UnityEngine.AI;

public class DropController : MonoBehaviour, IObjectGenerator
{
    public static DropController Instance { get; private set; }
    public int Priority { get { return 100; } }
    public DropSpec[] dropSpecs;
    public string dropLayer = "Drops";
    public float dropMergeRadius = 2f;
    public float inaccessibleDistance = 0.5f;
    private Dictionary<string, DropSpec> dropSpecLookup;
    private float inaccessibleThreshold;

    void Awake()
    {
        if(Instance != null && Instance != this)
            Destroy(gameObject);
        else
            Instance = this;
    }

    void Start()
    {
        inaccessibleThreshold = inaccessibleDistance * inaccessibleDistance;
        dropSpecLookup = dropSpecs.ToDictionary(x => x.dropName, x => x);
        print("Loaded " + dropSpecLookup.Count() + " drop specs");
        
        StartCoroutine(CleanUp());
    }

    private IEnumerator CleanUp()
    {
        while(true)
        {
            RemoveInaccessibleDrops();

            yield return new WaitForSeconds(5f);
        }
    }

    private void RemoveInaccessibleDrops()
    {
        List<GameObject> inaccessible = new List<GameObject>();

        for(int i = 0; i < transform.childCount; i++)
        {
            var child = transform.GetChild(i).gameObject;
            if (!NavMesh.SamplePosition(child.transform.position, out var hit, 1000f, NavMesh.AllAreas)
                        || IsOnNavMesh(child, hit))
            {
                inaccessible.Add(child);
            }
        }

        inaccessible = inaccessible.Where(i => Time.time - i.GetComponent<ItemStack>().CreateTime > 5f).ToList();

        if(inaccessible.Count > 0)
        {
            Debug.Log("Destroying inaccessible drops x " + inaccessible.Count);

            foreach(var child in inaccessible)
                Destroy(child);
        }
    }

    private bool IsOnNavMesh(GameObject child, NavMeshHit hit)
    {
        return Vector3.SqrMagnitude(child.transform.position - hit.position) > inaccessibleThreshold;
    }

    public void Generate(List<int> gameMap, int gameMapWidth, int gameMapHeight)
    {
        // Nothing to do here - drops generated by the player!
    }

    public GameObject Drop(DropSpec spec, Vector3 position, int quantity = 0)
    {
        var others = Physics.OverlapSphere(position, dropMergeRadius, LayerMask.GetMask(dropLayer))
            .Select(d => d.GetComponent<ItemStack>())
            .Where(d => d != null && d.dropSpec == spec)
            .OrderBy(d => d.quantity);

        int qtty = (quantity == 0) ? spec.dropRate : quantity;
        
        foreach(var other in others)
        {
            if(qtty + other.quantity > spec.stackSize)
                break;
                
            qtty += other.quantity;
            DestroyImmediate(other.gameObject);
        }

        var gameObject = Instantiate(spec.GetPrefabFor(qtty), position, Quaternion.identity, transform);
        var itemStack = gameObject.GetComponent<ItemStack>();
        itemStack.dropSpec = spec;
        itemStack.quantity = qtty;

        return gameObject;
    }

    public InventoryItem Pickup(ItemStack stack)
    {
        // Add any logic here to handle an inability to pick up a whole stack, stack splitting etc etc

        var item = new InventoryItem {dropSpec = stack.dropSpec, quantity = stack.quantity};

        DestroyImmediate(stack.gameObject);

        return item;
    }

    public List<DropItemSaveData> GetSaveData()
    {
        return GetComponentsInChildren<ItemStack>().Select(GetSaveData).ToList();
    }

    public void LoadDrops(List<DropItemSaveData> dropItemData)
    {
        Clear();

        foreach(var dropItem in dropItemData)
        {
            DropSpec dropSpec = dropSpecLookup[dropItem.dropSpecName];

            if(dropSpec == null)
            {
                Debug.LogError("Drop spec not found in list.  Assign it to the DropController in the editor.");
            }
            else
            {
                var pos = new Vector3(dropItem.positionX, dropItem.positionY, dropItem.positionZ);
                Drop(dropSpec, pos, dropItem.quantity);
            }
        }
    }

    public void Clear()
    {
        while (transform.childCount > 0)
            DestroyImmediate(transform.GetChild(0).gameObject);
    }

    private DropItemSaveData GetSaveData(ItemStack stack)
    {
        return new DropItemSaveData
        {
            positionX = stack.gameObject.transform.position.x,
            positionY = stack.gameObject.transform.position.y,
            positionZ = stack.gameObject.transform.position.z,
            dropSpecName = stack.dropSpec.dropName,
            quantity = stack.quantity
        };
    }
}
